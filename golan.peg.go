package golan

// Code generated by peg golan.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleroot
	ruleEOT
	rulestatements
	rulestatement
	rulewhile
	ruleexpression
	ruleassign
	ruleequality
	rulecompare
	ruleadditive
	rulemultitive
	rulefactor
	ruleunary
	rulepostfix
	rulefuncall
	ruleprimary
	ruleidentifier
	rule_
	rulenl
	rulecomment
	rulesp
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
)

var rul3s = [...]string{
	"Unknown",
	"root",
	"EOT",
	"statements",
	"statement",
	"while",
	"expression",
	"assign",
	"equality",
	"compare",
	"additive",
	"multitive",
	"factor",
	"unary",
	"postfix",
	"funcall",
	"primary",
	"identifier",
	"_",
	"nl",
	"comment",
	"sp",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Parser struct {
	ASTBuilder

	Buffer string
	buffer []rune
	rules  [52]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Parser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Parser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Parser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Parser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Parser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Parser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *Parser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.PushExpressionStatement()
		case ruleAction1:
			p.PushIf(begin)
		case ruleAction2:
			p.PushBlock()
		case ruleAction3:
			p.CompleteIf()
		case ruleAction4:
			p.PushWhile(begin)
		case ruleAction5:
			p.PushBlock()
		case ruleAction6:
			p.CompleteWhile()
		case ruleAction7:
			p.PushAssign()
		case ruleAction8:
			p.PushBinOp("==")
		case ruleAction9:
			p.PushBinOp("!=")
		case ruleAction10:
			p.PushBinOp("<=")
		case ruleAction11:
			p.PushBinOp(">=")
		case ruleAction12:
			p.PushBinOp("<")
		case ruleAction13:
			p.PushBinOp(">")
		case ruleAction14:
			p.PushBinOp("+")
		case ruleAction15:
			p.PushBinOp("-")
		case ruleAction16:
			p.PushBinOp("*")
		case ruleAction17:
			p.PushBinOp("/")
		case ruleAction18:
			p.PushBinOp("%")
		case ruleAction19:
			p.PushUnaryOp(begin, end, "-")
		case ruleAction20:
			p.PushUnaryOp(begin, end, "+")
		case ruleAction21:
			p.PushUnaryOp(begin, end, "!")
		case ruleAction22:
			p.CompleteUnary()
		case ruleAction23:
			p.PushApply()
		case ruleAction24:
			p.CompleteApply(end)
		case ruleAction25:
			p.PushApply()
		case ruleAction26:
			p.CompleteApply(end)
		case ruleAction27:
			p.PushIntLiteral(begin, end, text)
		case ruleAction28:
			p.PushIdentifier(begin, end, text)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*Parser) error {
	return func(p *Parser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Parser) error {
	return func(p *Parser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Parser) Init(options ...func(*Parser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 root <- <(statements EOT)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rulestatements]() {
					goto l0
				}
				if !_rules[ruleEOT]() {
					goto l0
				}
				add(ruleroot, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 EOT <- <!.> */
		func() bool {
			position2, tokenIndex2 := position, tokenIndex
			{
				position3 := position
				{
					position4, tokenIndex4 := position, tokenIndex
					if !matchDot() {
						goto l4
					}
					goto l2
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
				add(ruleEOT, position3)
			}
			return true
		l2:
			position, tokenIndex = position2, tokenIndex2
			return false
		},
		/* 2 statements <- <((sp statement)* sp)> */
		func() bool {
			position5, tokenIndex5 := position, tokenIndex
			{
				position6 := position
			l7:
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[rulesp]() {
						goto l8
					}
					if !_rules[rulestatement]() {
						goto l8
					}
					goto l7
				l8:
					position, tokenIndex = position8, tokenIndex8
				}
				if !_rules[rulesp]() {
					goto l5
				}
				add(rulestatements, position6)
			}
			return true
		l5:
			position, tokenIndex = position5, tokenIndex5
			return false
		},
		/* 3 statement <- <((expression _ comment? nl Action0) / while / (<('i' 'f')> Action1 _ expression _ '{' Action2 statements '}' Action3))> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				{
					position11, tokenIndex11 := position, tokenIndex
					if !_rules[ruleexpression]() {
						goto l12
					}
					if !_rules[rule_]() {
						goto l12
					}
					{
						position13, tokenIndex13 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l13
						}
						goto l14
					l13:
						position, tokenIndex = position13, tokenIndex13
					}
				l14:
					if !_rules[rulenl]() {
						goto l12
					}
					if !_rules[ruleAction0]() {
						goto l12
					}
					goto l11
				l12:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulewhile]() {
						goto l15
					}
					goto l11
				l15:
					position, tokenIndex = position11, tokenIndex11
					{
						position16 := position
						if buffer[position] != rune('i') {
							goto l9
						}
						position++
						if buffer[position] != rune('f') {
							goto l9
						}
						position++
						add(rulePegText, position16)
					}
					if !_rules[ruleAction1]() {
						goto l9
					}
					if !_rules[rule_]() {
						goto l9
					}
					if !_rules[ruleexpression]() {
						goto l9
					}
					if !_rules[rule_]() {
						goto l9
					}
					if buffer[position] != rune('{') {
						goto l9
					}
					position++
					if !_rules[ruleAction2]() {
						goto l9
					}
					if !_rules[rulestatements]() {
						goto l9
					}
					if buffer[position] != rune('}') {
						goto l9
					}
					position++
					if !_rules[ruleAction3]() {
						goto l9
					}
				}
			l11:
				add(rulestatement, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 4 while <- <(<('w' 'h' 'i' 'l' 'e')> Action4 _ expression _ '{' Action5 statements '}' Action6)> */
		func() bool {
			position17, tokenIndex17 := position, tokenIndex
			{
				position18 := position
				{
					position19 := position
					if buffer[position] != rune('w') {
						goto l17
					}
					position++
					if buffer[position] != rune('h') {
						goto l17
					}
					position++
					if buffer[position] != rune('i') {
						goto l17
					}
					position++
					if buffer[position] != rune('l') {
						goto l17
					}
					position++
					if buffer[position] != rune('e') {
						goto l17
					}
					position++
					add(rulePegText, position19)
				}
				if !_rules[ruleAction4]() {
					goto l17
				}
				if !_rules[rule_]() {
					goto l17
				}
				if !_rules[ruleexpression]() {
					goto l17
				}
				if !_rules[rule_]() {
					goto l17
				}
				if buffer[position] != rune('{') {
					goto l17
				}
				position++
				if !_rules[ruleAction5]() {
					goto l17
				}
				if !_rules[rulestatements]() {
					goto l17
				}
				if buffer[position] != rune('}') {
					goto l17
				}
				position++
				if !_rules[ruleAction6]() {
					goto l17
				}
				add(rulewhile, position18)
			}
			return true
		l17:
			position, tokenIndex = position17, tokenIndex17
			return false
		},
		/* 5 expression <- <(assign / equality)> */
		func() bool {
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				{
					position22, tokenIndex22 := position, tokenIndex
					if !_rules[ruleassign]() {
						goto l23
					}
					goto l22
				l23:
					position, tokenIndex = position22, tokenIndex22
					if !_rules[ruleequality]() {
						goto l20
					}
				}
			l22:
				add(ruleexpression, position21)
			}
			return true
		l20:
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 6 assign <- <(identifier _ '=' _ expression Action7)> */
		func() bool {
			position24, tokenIndex24 := position, tokenIndex
			{
				position25 := position
				if !_rules[ruleidentifier]() {
					goto l24
				}
				if !_rules[rule_]() {
					goto l24
				}
				if buffer[position] != rune('=') {
					goto l24
				}
				position++
				if !_rules[rule_]() {
					goto l24
				}
				if !_rules[ruleexpression]() {
					goto l24
				}
				if !_rules[ruleAction7]() {
					goto l24
				}
				add(ruleassign, position25)
			}
			return true
		l24:
			position, tokenIndex = position24, tokenIndex24
			return false
		},
		/* 7 equality <- <(compare ((_ ('=' '=') _ compare Action8) / (_ ('!' '=') _ compare Action9))*)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if !_rules[rulecompare]() {
					goto l26
				}
			l28:
				{
					position29, tokenIndex29 := position, tokenIndex
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rule_]() {
							goto l31
						}
						if buffer[position] != rune('=') {
							goto l31
						}
						position++
						if buffer[position] != rune('=') {
							goto l31
						}
						position++
						if !_rules[rule_]() {
							goto l31
						}
						if !_rules[rulecompare]() {
							goto l31
						}
						if !_rules[ruleAction8]() {
							goto l31
						}
						goto l30
					l31:
						position, tokenIndex = position30, tokenIndex30
						if !_rules[rule_]() {
							goto l29
						}
						if buffer[position] != rune('!') {
							goto l29
						}
						position++
						if buffer[position] != rune('=') {
							goto l29
						}
						position++
						if !_rules[rule_]() {
							goto l29
						}
						if !_rules[rulecompare]() {
							goto l29
						}
						if !_rules[ruleAction9]() {
							goto l29
						}
					}
				l30:
					goto l28
				l29:
					position, tokenIndex = position29, tokenIndex29
				}
				add(ruleequality, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 8 compare <- <(additive ((_ ('<' '=') _ additive Action10) / (_ ('>' '=') _ additive Action11) / (_ '<' _ additive Action12) / (_ '>' _ additive Action13))*)> */
		func() bool {
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if !_rules[ruleadditive]() {
					goto l32
				}
			l34:
				{
					position35, tokenIndex35 := position, tokenIndex
					{
						position36, tokenIndex36 := position, tokenIndex
						if !_rules[rule_]() {
							goto l37
						}
						if buffer[position] != rune('<') {
							goto l37
						}
						position++
						if buffer[position] != rune('=') {
							goto l37
						}
						position++
						if !_rules[rule_]() {
							goto l37
						}
						if !_rules[ruleadditive]() {
							goto l37
						}
						if !_rules[ruleAction10]() {
							goto l37
						}
						goto l36
					l37:
						position, tokenIndex = position36, tokenIndex36
						if !_rules[rule_]() {
							goto l38
						}
						if buffer[position] != rune('>') {
							goto l38
						}
						position++
						if buffer[position] != rune('=') {
							goto l38
						}
						position++
						if !_rules[rule_]() {
							goto l38
						}
						if !_rules[ruleadditive]() {
							goto l38
						}
						if !_rules[ruleAction11]() {
							goto l38
						}
						goto l36
					l38:
						position, tokenIndex = position36, tokenIndex36
						if !_rules[rule_]() {
							goto l39
						}
						if buffer[position] != rune('<') {
							goto l39
						}
						position++
						if !_rules[rule_]() {
							goto l39
						}
						if !_rules[ruleadditive]() {
							goto l39
						}
						if !_rules[ruleAction12]() {
							goto l39
						}
						goto l36
					l39:
						position, tokenIndex = position36, tokenIndex36
						if !_rules[rule_]() {
							goto l35
						}
						if buffer[position] != rune('>') {
							goto l35
						}
						position++
						if !_rules[rule_]() {
							goto l35
						}
						if !_rules[ruleadditive]() {
							goto l35
						}
						if !_rules[ruleAction13]() {
							goto l35
						}
					}
				l36:
					goto l34
				l35:
					position, tokenIndex = position35, tokenIndex35
				}
				add(rulecompare, position33)
			}
			return true
		l32:
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 9 additive <- <(multitive ((_ '+' _ multitive Action14) / (_ '-' _ multitive Action15))*)> */
		func() bool {
			position40, tokenIndex40 := position, tokenIndex
			{
				position41 := position
				if !_rules[rulemultitive]() {
					goto l40
				}
			l42:
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position44, tokenIndex44 := position, tokenIndex
						if !_rules[rule_]() {
							goto l45
						}
						if buffer[position] != rune('+') {
							goto l45
						}
						position++
						if !_rules[rule_]() {
							goto l45
						}
						if !_rules[rulemultitive]() {
							goto l45
						}
						if !_rules[ruleAction14]() {
							goto l45
						}
						goto l44
					l45:
						position, tokenIndex = position44, tokenIndex44
						if !_rules[rule_]() {
							goto l43
						}
						if buffer[position] != rune('-') {
							goto l43
						}
						position++
						if !_rules[rule_]() {
							goto l43
						}
						if !_rules[rulemultitive]() {
							goto l43
						}
						if !_rules[ruleAction15]() {
							goto l43
						}
					}
				l44:
					goto l42
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
				add(ruleadditive, position41)
			}
			return true
		l40:
			position, tokenIndex = position40, tokenIndex40
			return false
		},
		/* 10 multitive <- <(factor ((_ '*' _ factor Action16) / (_ '/' _ factor Action17) / (_ '%' _ factor Action18))*)> */
		func() bool {
			position46, tokenIndex46 := position, tokenIndex
			{
				position47 := position
				if !_rules[rulefactor]() {
					goto l46
				}
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					{
						position50, tokenIndex50 := position, tokenIndex
						if !_rules[rule_]() {
							goto l51
						}
						if buffer[position] != rune('*') {
							goto l51
						}
						position++
						if !_rules[rule_]() {
							goto l51
						}
						if !_rules[rulefactor]() {
							goto l51
						}
						if !_rules[ruleAction16]() {
							goto l51
						}
						goto l50
					l51:
						position, tokenIndex = position50, tokenIndex50
						if !_rules[rule_]() {
							goto l52
						}
						if buffer[position] != rune('/') {
							goto l52
						}
						position++
						if !_rules[rule_]() {
							goto l52
						}
						if !_rules[rulefactor]() {
							goto l52
						}
						if !_rules[ruleAction17]() {
							goto l52
						}
						goto l50
					l52:
						position, tokenIndex = position50, tokenIndex50
						if !_rules[rule_]() {
							goto l49
						}
						if buffer[position] != rune('%') {
							goto l49
						}
						position++
						if !_rules[rule_]() {
							goto l49
						}
						if !_rules[rulefactor]() {
							goto l49
						}
						if !_rules[ruleAction18]() {
							goto l49
						}
					}
				l50:
					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				add(rulemultitive, position47)
			}
			return true
		l46:
			position, tokenIndex = position46, tokenIndex46
			return false
		},
		/* 11 factor <- <(unary / postfix)> */
		func() bool {
			position53, tokenIndex53 := position, tokenIndex
			{
				position54 := position
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleunary]() {
						goto l56
					}
					goto l55
				l56:
					position, tokenIndex = position55, tokenIndex55
					if !_rules[rulepostfix]() {
						goto l53
					}
				}
			l55:
				add(rulefactor, position54)
			}
			return true
		l53:
			position, tokenIndex = position53, tokenIndex53
			return false
		},
		/* 12 unary <- <(((<'-'> Action19) / (<'+'> Action20) / (<'!'> Action21)) _ factor Action22)> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				{
					position59, tokenIndex59 := position, tokenIndex
					{
						position61 := position
						if buffer[position] != rune('-') {
							goto l60
						}
						position++
						add(rulePegText, position61)
					}
					if !_rules[ruleAction19]() {
						goto l60
					}
					goto l59
				l60:
					position, tokenIndex = position59, tokenIndex59
					{
						position63 := position
						if buffer[position] != rune('+') {
							goto l62
						}
						position++
						add(rulePegText, position63)
					}
					if !_rules[ruleAction20]() {
						goto l62
					}
					goto l59
				l62:
					position, tokenIndex = position59, tokenIndex59
					{
						position64 := position
						if buffer[position] != rune('!') {
							goto l57
						}
						position++
						add(rulePegText, position64)
					}
					if !_rules[ruleAction21]() {
						goto l57
					}
				}
			l59:
				if !_rules[rule_]() {
					goto l57
				}
				if !_rules[rulefactor]() {
					goto l57
				}
				if !_rules[ruleAction22]() {
					goto l57
				}
				add(ruleunary, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 13 postfix <- <(primary funcall*)> */
		func() bool {
			position65, tokenIndex65 := position, tokenIndex
			{
				position66 := position
				if !_rules[ruleprimary]() {
					goto l65
				}
			l67:
				{
					position68, tokenIndex68 := position, tokenIndex
					if !_rules[rulefuncall]() {
						goto l68
					}
					goto l67
				l68:
					position, tokenIndex = position68, tokenIndex68
				}
				add(rulepostfix, position66)
			}
			return true
		l65:
			position, tokenIndex = position65, tokenIndex65
			return false
		},
		/* 14 funcall <- <((_ '(' Action23 sp _ <')'> Action24) / ('(' Action25 sp _ expression (_ ',' sp _ expression)* (_ ',')? sp _ <')'> Action26))> */
		func() bool {
			position69, tokenIndex69 := position, tokenIndex
			{
				position70 := position
				{
					position71, tokenIndex71 := position, tokenIndex
					if !_rules[rule_]() {
						goto l72
					}
					if buffer[position] != rune('(') {
						goto l72
					}
					position++
					if !_rules[ruleAction23]() {
						goto l72
					}
					if !_rules[rulesp]() {
						goto l72
					}
					if !_rules[rule_]() {
						goto l72
					}
					{
						position73 := position
						if buffer[position] != rune(')') {
							goto l72
						}
						position++
						add(rulePegText, position73)
					}
					if !_rules[ruleAction24]() {
						goto l72
					}
					goto l71
				l72:
					position, tokenIndex = position71, tokenIndex71
					if buffer[position] != rune('(') {
						goto l69
					}
					position++
					if !_rules[ruleAction25]() {
						goto l69
					}
					if !_rules[rulesp]() {
						goto l69
					}
					if !_rules[rule_]() {
						goto l69
					}
					if !_rules[ruleexpression]() {
						goto l69
					}
				l74:
					{
						position75, tokenIndex75 := position, tokenIndex
						if !_rules[rule_]() {
							goto l75
						}
						if buffer[position] != rune(',') {
							goto l75
						}
						position++
						if !_rules[rulesp]() {
							goto l75
						}
						if !_rules[rule_]() {
							goto l75
						}
						if !_rules[ruleexpression]() {
							goto l75
						}
						goto l74
					l75:
						position, tokenIndex = position75, tokenIndex75
					}
					{
						position76, tokenIndex76 := position, tokenIndex
						if !_rules[rule_]() {
							goto l76
						}
						if buffer[position] != rune(',') {
							goto l76
						}
						position++
						goto l77
					l76:
						position, tokenIndex = position76, tokenIndex76
					}
				l77:
					if !_rules[rulesp]() {
						goto l69
					}
					if !_rules[rule_]() {
						goto l69
					}
					{
						position78 := position
						if buffer[position] != rune(')') {
							goto l69
						}
						position++
						add(rulePegText, position78)
					}
					if !_rules[ruleAction26]() {
						goto l69
					}
				}
			l71:
				add(rulefuncall, position70)
			}
			return true
		l69:
			position, tokenIndex = position69, tokenIndex69
			return false
		},
		/* 15 primary <- <(('(' _ expression _ ')') / (<[0-9]+> Action27) / identifier)> */
		func() bool {
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				{
					position81, tokenIndex81 := position, tokenIndex
					if buffer[position] != rune('(') {
						goto l82
					}
					position++
					if !_rules[rule_]() {
						goto l82
					}
					if !_rules[ruleexpression]() {
						goto l82
					}
					if !_rules[rule_]() {
						goto l82
					}
					if buffer[position] != rune(')') {
						goto l82
					}
					position++
					goto l81
				l82:
					position, tokenIndex = position81, tokenIndex81
					{
						position84 := position
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l83
						}
						position++
					l85:
						{
							position86, tokenIndex86 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l86
							}
							position++
							goto l85
						l86:
							position, tokenIndex = position86, tokenIndex86
						}
						add(rulePegText, position84)
					}
					if !_rules[ruleAction27]() {
						goto l83
					}
					goto l81
				l83:
					position, tokenIndex = position81, tokenIndex81
					if !_rules[ruleidentifier]() {
						goto l79
					}
				}
			l81:
				add(ruleprimary, position80)
			}
			return true
		l79:
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 16 identifier <- <(<(('_' / [a-z] / [A-Z]) ('_' / [a-z] / [A-Z] / [0-9])*)> Action28)> */
		func() bool {
			position87, tokenIndex87 := position, tokenIndex
			{
				position88 := position
				{
					position89 := position
					{
						position90, tokenIndex90 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l91
						}
						position++
						goto l90
					l91:
						position, tokenIndex = position90, tokenIndex90
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l92
						}
						position++
						goto l90
					l92:
						position, tokenIndex = position90, tokenIndex90
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l87
						}
						position++
					}
				l90:
				l93:
					{
						position94, tokenIndex94 := position, tokenIndex
						{
							position95, tokenIndex95 := position, tokenIndex
							if buffer[position] != rune('_') {
								goto l96
							}
							position++
							goto l95
						l96:
							position, tokenIndex = position95, tokenIndex95
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l97
							}
							position++
							goto l95
						l97:
							position, tokenIndex = position95, tokenIndex95
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l98
							}
							position++
							goto l95
						l98:
							position, tokenIndex = position95, tokenIndex95
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l94
							}
							position++
						}
					l95:
						goto l93
					l94:
						position, tokenIndex = position94, tokenIndex94
					}
					add(rulePegText, position89)
				}
				if !_rules[ruleAction28]() {
					goto l87
				}
				add(ruleidentifier, position88)
			}
			return true
		l87:
			position, tokenIndex = position87, tokenIndex87
			return false
		},
		/* 17 _ <- <(' ' / '\t')*> */
		func() bool {
			{
				position100 := position
			l101:
				{
					position102, tokenIndex102 := position, tokenIndex
					{
						position103, tokenIndex103 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l104
						}
						position++
						goto l103
					l104:
						position, tokenIndex = position103, tokenIndex103
						if buffer[position] != rune('\t') {
							goto l102
						}
						position++
					}
				l103:
					goto l101
				l102:
					position, tokenIndex = position102, tokenIndex102
				}
				add(rule_, position100)
			}
			return true
		},
		/* 18 nl <- <('\r' / '\n')+> */
		func() bool {
			position105, tokenIndex105 := position, tokenIndex
			{
				position106 := position
				{
					position109, tokenIndex109 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l110
					}
					position++
					goto l109
				l110:
					position, tokenIndex = position109, tokenIndex109
					if buffer[position] != rune('\n') {
						goto l105
					}
					position++
				}
			l109:
			l107:
				{
					position108, tokenIndex108 := position, tokenIndex
					{
						position111, tokenIndex111 := position, tokenIndex
						if buffer[position] != rune('\r') {
							goto l112
						}
						position++
						goto l111
					l112:
						position, tokenIndex = position111, tokenIndex111
						if buffer[position] != rune('\n') {
							goto l108
						}
						position++
					}
				l111:
					goto l107
				l108:
					position, tokenIndex = position108, tokenIndex108
				}
				add(rulenl, position106)
			}
			return true
		l105:
			position, tokenIndex = position105, tokenIndex105
			return false
		},
		/* 19 comment <- <('#' (!('\r' / '\n') .)*)> */
		func() bool {
			position113, tokenIndex113 := position, tokenIndex
			{
				position114 := position
				if buffer[position] != rune('#') {
					goto l113
				}
				position++
			l115:
				{
					position116, tokenIndex116 := position, tokenIndex
					{
						position117, tokenIndex117 := position, tokenIndex
						{
							position118, tokenIndex118 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l119
							}
							position++
							goto l118
						l119:
							position, tokenIndex = position118, tokenIndex118
							if buffer[position] != rune('\n') {
								goto l117
							}
							position++
						}
					l118:
						goto l116
					l117:
						position, tokenIndex = position117, tokenIndex117
					}
					if !matchDot() {
						goto l116
					}
					goto l115
				l116:
					position, tokenIndex = position116, tokenIndex116
				}
				add(rulecomment, position114)
			}
			return true
		l113:
			position, tokenIndex = position113, tokenIndex113
			return false
		},
		/* 20 sp <- <(_ comment? nl _)*> */
		func() bool {
			{
				position121 := position
			l122:
				{
					position123, tokenIndex123 := position, tokenIndex
					if !_rules[rule_]() {
						goto l123
					}
					{
						position124, tokenIndex124 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l124
						}
						goto l125
					l124:
						position, tokenIndex = position124, tokenIndex124
					}
				l125:
					if !_rules[rulenl]() {
						goto l123
					}
					if !_rules[rule_]() {
						goto l123
					}
					goto l122
				l123:
					position, tokenIndex = position123, tokenIndex123
				}
				add(rulesp, position121)
			}
			return true
		},
		/* 22 Action0 <- <{ p.PushExpressionStatement() }> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		nil,
		/* 24 Action1 <- <{ p.PushIf(begin) }> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 25 Action2 <- <{ p.PushBlock() }> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 26 Action3 <- <{ p.CompleteIf() }> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 27 Action4 <- <{ p.PushWhile(begin) }> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 28 Action5 <- <{ p.PushBlock() }> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 29 Action6 <- <{ p.CompleteWhile() }> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 30 Action7 <- <{ p.PushAssign() }> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 31 Action8 <- <{ p.PushBinOp("==") }> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 32 Action9 <- <{ p.PushBinOp("!=") }> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 33 Action10 <- <{ p.PushBinOp("<=") }> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 34 Action11 <- <{ p.PushBinOp(">=") }> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 35 Action12 <- <{ p.PushBinOp("<") }> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 36 Action13 <- <{ p.PushBinOp(">") }> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 37 Action14 <- <{ p.PushBinOp("+") }> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 38 Action15 <- <{ p.PushBinOp("-") }> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 39 Action16 <- <{ p.PushBinOp("*") }> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 40 Action17 <- <{ p.PushBinOp("/") }> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 41 Action18 <- <{ p.PushBinOp("%") }> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 42 Action19 <- <{ p.PushUnaryOp(begin, end, "-") }> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 43 Action20 <- <{ p.PushUnaryOp(begin, end, "+") }> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 44 Action21 <- <{ p.PushUnaryOp(begin, end, "!") }> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 45 Action22 <- <{ p.CompleteUnary() }> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 46 Action23 <- <{ p.PushApply() }> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 47 Action24 <- <{ p.CompleteApply(end) }> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 48 Action25 <- <{ p.PushApply() }> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 49 Action26 <- <{ p.CompleteApply(end) }> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 50 Action27 <- <{ p.PushIntLiteral(begin, end, text) }> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		/* 51 Action28 <- <{ p.PushIdentifier(begin, end, text) }> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
