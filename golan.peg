package golan

type Parser Peg {
	ASTBuilder
}

root <- statements EOT

EOT <- !.

statements <- (sp statement)* sp

statement <- (
	expression _ comment? nl { p.PushExpressionStatement() } /
	<'while'> { p.PushWhile(begin) } _ expression _ '{' { p.PushBlock() } statements '}' { p.CompleteWhile() }
)

expression <- assign / equality

assign <- identifier _ '=' _ expression		{ p.PushAssign() }

equality <- compare (
	_ '==' _ compare	{ p.PushBinOp("==") } /
	_ '!=' _ compare	{ p.PushBinOp("!=") }
)*

compare <- additive (
	_ '<=' _ additive	{ p.PushBinOp("<=") } /
	_ '>=' _ additive	{ p.PushBinOp(">=") } /
	_ '<' _ additive	{ p.PushBinOp("<") } /
	_ '>' _ additive	{ p.PushBinOp(">") }
)*

additive <- multitive (
	_ '+' _ multitive	{ p.PushBinOp("+") } /
	_ '-' _ multitive	{ p.PushBinOp("-") }
)*

multitive <- factor (
	_ '*' _ factor	{ p.PushBinOp("*") } /
	_ '/' _ factor	{ p.PushBinOp("/") } /
	_ '%' _ factor	{ p.PushBinOp("%") }
)*

factor <- unary / postfix

unary <- (
	<'-'> { p.PushUnaryOp(begin, end, "-") } /
	<'+'> { p.PushUnaryOp(begin, end, "+") } /
	<'!'> { p.PushUnaryOp(begin, end, "!") }
) _ factor { p.CompleteUnary() }

postfix <- primary (
    _ '(' { p.PushApply() } sp _
    (expression (_ ',' sp _ expression)*)?
    sp _ <')'> { p.CompleteApply(end) } _
)*

primary <-
	'(' _ expression _ ')' /
	<[0-9]+>	{ p.PushIntLiteral(begin, end, text) } /
	identifier

identifier <- <[_a-zA-Z][_a-zA-Z0-9]*>	{ p.PushIdentifier(begin, end, text) }

_ <- [ \t]*

nl <- [\r\n]+

comment <- '#' [^\r\n]*

sp <- (_ comment? nl _)*

